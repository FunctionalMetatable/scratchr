package scratch.projectanalyzer;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.management.ObjectName;

/**
 * Parses relevant information from Scratch Projects
 *
 */
public class ProjectParser {
	
	List<String> allImages; // all images in library
	List<String> allSounds; // all sounds in library
	
	Object[][] objects;  // objects obtained from ObjReader 
	HashMap<String,String> info; // info map obtained from ObjReader
	
	// Data captured for tables
	Map<String,Object> infoMap;
	Map<String,Object> blocksMap;
	List<Map<String,Object>> mediaList;
	List<Map<String,Object>> saveHistoryList;
	List<Map<String,Object>> shareHistoryList;
	List<Map<String,Object>> midiList;
	List<Map<String,Object>> drumsList;
	List<Map<String,Object>> spriteList;
	List<Map<String,Object>> spriteStackList;
	List<Map<String,Object>> stringsList;
	List<Map<String,Object>> disconnectedBlocksList;
	
	Integer numSprites;
	
	/**
	 * Creates an ObjectParser that can be used to parse multiple files. 
	 * @param allImages
	 * @param allSounds
	 */
	public ProjectParser(List<String> allImages, List<String> allSounds) {
		this.allImages = allImages;
		this.allSounds = allSounds;
	}
	
	/**
	 * Evaluates a particular file and retrieves all necessary data from that file.
	 * Must be called before data retrieval methods are called.
	 * @param file
	 * @throws IOException
	 */
	public void evaluateFile(File file) throws IOException {
		FileInputStream fileStream = new FileInputStream(file);
		ObjReader reader = new ObjReader(fileStream);
		objects = reader.getObjectTable();
		info = reader.getInfoTable();
		fileStream.close();	
		
		infoMap = new HashMap<String,Object>();
		blocksMap = new HashMap<String,Object>();
		mediaList = new ArrayList<Map<String,Object>>();
		midiList = new ArrayList<Map<String,Object>>();
		drumsList = new ArrayList<Map<String,Object>>();
		numSprites = new Integer(0);	
		shareHistoryList = new ArrayList<Map<String,Object>>();
		saveHistoryList = new ArrayList<Map<String,Object>>();
		spriteList = new ArrayList<Map<String,Object>>();
		spriteStackList = new ArrayList<Map<String,Object>>();
		stringsList = new ArrayList<Map<String,Object>>();
		disconnectedBlocksList = new ArrayList<Map<String,Object>>();
		
		evaluateObjects();
		evaluateInfo();
		infoMap.put("numsprites",numSprites); // num sprites generated by evaluateObjects()
		if (FileUtils.isFileOfType(file, "hid")) {
			infoMap.put("hidden", "1");
		}
	}

	/**
	 * Returns a Map mapping a block to the number of occurrences of the block in the
	 * project file.
	 * @return
	 */
	public Map<String, Object> getBlocksUsage() {
		return blocksMap;
	}
	
	public List<Map<String,Object>> getInstrumentsUsage() {
		return midiList;
	}
	
	public List<Map<String,Object>> getDrumsUsage() {
		return drumsList;
	}
	
	public List<Map<String,Object>> getMediaUsage() {
		return mediaList;
	}
	
	public List<Map<String,Object>> getShareHistory() {
		return shareHistoryList;
	}
	
	public List<Map<String,Object>> getSaveHistory() {
		return saveHistoryList;
	}
	
	public Map<String,Object> getInfo() {
		return infoMap;
	}
	
	public List<Map<String,Object>> getSpriteStack() {
		return spriteStackList;
	}
	
	public List<Map<String,Object>> getSpritesInfo() {
		return spriteList;
	}
	
	public List<Map<String,Object>> getUserStrings() {
		return stringsList;
	}
	
	public List<Map<String,Object>> getDisconnectedBlocks() {
		return disconnectedBlocksList;
	}
	
	/**
	 * Parses and stores the relevant project information
	 */
	private void evaluateObjects() {
		int spriteCounter = 0;
		int spriteId = 0;
		for (Object[] entry : objects) {			
			int classID = ((Number) entry[1]).intValue();			
			// if not sprite nor stage, do not evaluate
			if (!(classID == ScratchConstants.SCRATCHSPRITEMORPH_CLASSID) && 
					!(classID == ScratchConstants.SCRATCHSTAGEMORPH_CLASSID)) { 
				continue;
			}
			
			// give this sprite a unique id, id for stage = 0
			numSprites++;
			if (classID == ScratchConstants.SCRATCHSTAGEMORPH_CLASSID) {
				spriteId = 0;
			} else {
				spriteCounter++;
				spriteId = spriteCounter;
			}
			
			// evaluate blocks
			Object[] blocksStack = (Object[]) entry[11];
			String blockString = "";
			String prettyString = "";
			int scripts=0;
			boolean connected = true;
			for (Object obj : blocksStack) {					
				if (obj instanceof Object[] && ((Object[])obj).length >= 2) {
					Object blocksListObject = ((Object[])obj)[1];
					if (blocksListObject instanceof Object[]) {
						Object[] blocksList = (Object[])blocksListObject;			
						if (blocksList.length > 0) {
							String blockName = (String) ((Object[])blocksList[0])[0];
							if (blockName.endsWith("HatMorph") || blockName.endsWith("HatBlockMorph")) {							
								scripts++;
								connected = true;
							} else {
								connected = false;
							}
							prettyString += BlocksPrinter.printStack(blocksList)+"\n";
							blockString += "(";
							for (Object block : blocksList) {
								blockString += evaluateBlock(block, spriteId, connected);
							}
							blockString += ")";
						}
					}
				}
			}
			
			HashMap<String,Object> spriteStackMap = new HashMap<String,Object>();
			spriteStackMap.put("sprite_id", spriteId);
			spriteStackMap.put("stack", blockString);
			spriteStackMap.put("human_readable", prettyString);
			spriteStackList.add(spriteStackMap);

			// evaluate lists to capture user generated strings - list names and values
			if (entry.length > 23) {
				Object[] listStack = (Object[])entry[23];
				for (int i=0; i<listStack.length; i++) {
					HashMap<String,Object> listName = new HashMap<String,Object>(3);
					listName.put("sprite_id", spriteId);
					listName.put("string", listStack[i].toString());
					listName.put("type", "list_name");
					stringsList.add(listName);
					i++;
					Object[] listVals = (Object[])((Object[])listStack[i])[12];
					for (Object value : listVals) {
						HashMap<String,Object> listValue = new HashMap<String,Object>(3);
						listValue.put("sprite_id", spriteId);
						listValue.put("string", value.toString());
						listValue.put("type", "list_value");
						stringsList.add(listValue);
					}
				}
			}
				
			// evaluate variables to capture user generated strings - variable names and values
			Object[] varStack = (Object[])entry[10];
			for (int i=0; i<varStack.length; i++) {
				HashMap<String,Object> varName = new HashMap<String,Object>(3);
				varName.put("sprite_id", spriteId);
				varName.put("string", varStack[i].toString());
				varName.put("type", "variable_name");
				stringsList.add(varName);
				i++;
				HashMap<String,Object> varValue = new HashMap<String,Object>(3);
				varValue.put("sprite_id", spriteId);
				varValue.put("string", varStack[i].toString());
				varValue.put("type", "variable_value");
				stringsList.add(varValue);
			}
				
			// evaluate all media 
			Object[] mediaStack = (Object[]) entry[13];
			int sounds=0;
			int images=0;
			for (Object media : mediaStack) {
				Object[] mediaContents = (Object[])media;
				HashMap<String, Object> mediaMap = new HashMap<String, Object>(4);
				String name = mediaContents[3].toString();
				mediaMap.put("name", name);
				mediaMap.put("sprite_id", spriteId);
				
				int mediaId = ((Integer)mediaContents[1]).intValue();
					
				if (mediaId == ScratchConstants.IMAGEMEDIA_CLASSID) {
					images++;
					mediaMap.put("type", "image");
					Object[] data = (Object[])objects[((Ref)((Object[])mediaContents[4])[4]).index];
					int size = 0;
					if (data[0] instanceof int[]) {
						size = ((int[])data[0]).length;
					} else if (data[0] instanceof byte[]) {
						size = ((byte[])data[0]).length;
					}
					mediaMap.put("size", size);
						
					if (allImages.contains(name)) 
						mediaMap.put("library", "1");
				}
					
				if (mediaId == ScratchConstants.SOUNDMEDIA_CLASSID) {
					sounds++;
					mediaMap.put("type", "sound");
					int size; 	
					// use compressed data if available
					if (mediaContents.length > 9 && mediaContents[9] instanceof byte[]) {
						size = ((byte[])mediaContents[9]).length;
					} else {
						size = ((byte[])((Object[])mediaContents[4])[6]).length;
					}
					mediaMap.put("size", size);
						
					if (allSounds.contains(name)) 
						mediaMap.put("library", "1");
				}
					
				mediaList.add(mediaMap);
			}
			
			// capture sprite summary information				
			HashMap<String,Object> spritesInfo = new HashMap<String,Object>();
			spritesInfo.put("sprite_id", spriteId);
			if (entry[9] instanceof String)
				spritesInfo.put("name", (String) entry[9]);
			spritesInfo.put("scripts", scripts);	
			spritesInfo.put("sounds", sounds);
			spritesInfo.put("images", images);
			spriteList.add(spritesInfo);
				
		}
		
		numSprites -= 1; // remove stage from sprite count
	}
	
	/**
	 * Parses and stores relevant project metadata 
	 */
	private void evaluateInfo() {		
		String currentUserName = "";
		String currentProjectName = "";
		String basedOnUserName = "";
		String basedOnProjectName = "";
		
		for (String key : info.keySet()) {
			if (key.equals("thumbnail") || key.equals("penTrails"))  // do not store thumbnail and penTrails bitmaps
				continue;
			
			String value = info.get(key);
			value = value.replace("\r", "\n");
			
			if (key.equals("history")) {
				String[] lines =  value.split("\n");
				for (int i=lines.length-1; i>=0; i--) {
					String[] tabs = lines[i].split("\t");
					
					if (tabs.length < 2)
						continue;
					
					HashMap<String, Object> historyMap = new HashMap<String,Object>(4);
					historyMap.put("date", tabs[0]);
					if (tabs.length > 2)
						historyMap.put("filename", tabs[2]);
					if (tabs.length > 3)
						historyMap.put("local_name", tabs[3]);
					if (tabs.length > 4)
						historyMap.put("share_name", tabs[4]);

					if (tabs[1].equals("save")) {						
						saveHistoryList.add(historyMap);
					}
					
					if (tabs[1].equals("share")) {
						shareHistoryList.add(historyMap);
						if (basedOnUserName.equals("") && tabs.length > 3) {
							if (currentUserName.equals("")) { 
								// this is the current user & file name
								currentUserName = tabs[3];
								currentProjectName = tabs[2];
							} else if (!currentUserName.equalsIgnoreCase(tabs[3]) || !currentProjectName.equalsIgnoreCase(tabs[2])) {
								basedOnUserName = tabs[3];
								basedOnProjectName = tabs[2];
								infoMap.put("based_on_project_name", basedOnProjectName);
								infoMap.put("based_on_username", basedOnUserName);
								if (Loader.ENABLE_REMIX_PROJECT_QUERYING) {  // query for remixed from project id
									String basedOnProjectId = findProjectId(basedOnProjectName, basedOnUserName);
									if (!basedOnProjectId.equals(""))
										infoMap.put("based_on_project_id", findProjectId(basedOnProjectName, basedOnUserName));
								}
							}
						}
					}
				}
			}
			
			if (key.equals("hasMotorBlocks") || key.equals("isHosting")) {
				if (value.equals("true")) {
					value = "1";
				} else {
					value = "0";
				}
			}
			
			infoMap.put(key, value);
		}
	}
	
	/**
	 * 
	 * @param block
	 * @param spriteId
	 * @param connected
	 * @return the String representation of the blocks stack for <code>block</code>
	 */
	private String evaluateBlock(Object block, int spriteId, boolean connected) {
		String representation = "";
		
		if (block instanceof Object[]) {
			Object[] list = (Object[])block;
			if (list.length < 1) { // no blocks in list
				return representation;
			}
			
			representation += " (";
			
			if (list[0] instanceof Object[]) {
				representation += evaluateBlock(list[0], spriteId, connected);
			} else {
				String key = ScratchConstants.convertBlocksString(list[0].toString());
				if (key.equals("EventHatMorph")) { 
					if (!(list[1] instanceof Object[]) && list[1].toString().equals("Scratch-StartClicked")) {  // specifically capture if this EventHatMorph is the green flag block
						key = "EventHatMorph_StartClicked";
					}
				}
				if (key.equals("changeVariable")) {  // pick up the type of changeVariable block
					key = ScratchConstants.convertBlocksString(list[2].toString());
				}
				
				if (connected || key.equals("scratchComment")) {  // for all connected blocks and comments
					Integer value = (Integer)blocksMap.get(key);
					if (value == null) {
						blocksMap.put(key, 1);
					} else {
						blocksMap.put(key, value+1);
					}
					
					if (key.equals("midiInstrument_")) {
						HashMap<String, Object> map = new HashMap<String,Object>(1);
						if (list[1] instanceof Object[]) {
							map.put("other", ((Object[])list[1])[0].toString());
						} else {
							map.put("instrument", list[1].toString());
						}
						midiList.add(map);
					}
					
					if (key.equals("drum_duration_elapsed_from_")) {
						HashMap<String, Object> map = new HashMap<String,Object>(1);
						if (list[1] instanceof Object[]) {
							map.put("other", ((Object[])list[1])[0].toString());
						} else {
							map.put("drum", list[1].toString());
						}
						drumsList.add(map);
					}
				} else {
					HashMap<String,Object> map = new HashMap<String,Object>(3);
					map.put("sprite_id", spriteId);
					map.put("block", list[0].toString());
					disconnectedBlocksList.add(map);
				}

				if (key.equals("EventHatMorph") || key.equals("broadcast_") || key.equals("doBroadcastAndWait")) {
					if (!(list[1] instanceof Object[])) {  // capture user generated strings
						HashMap<String,Object> map = new HashMap<String,Object>(3);
						map.put("sprite_id", spriteId);
						map.put("string", list[1].toString());
						map.put("type", "broadcast");
						stringsList.add(map);
					}
				}
				
				if (key.equals("scratchComment")) {  // capture comments as a user generated string
					HashMap<String,Object> map = new HashMap<String,Object>(3);
					map.put("sprite_id", spriteId);
					map.put("string", list[1].toString());
					map.put("type", "comment");
					stringsList.add(map);
				}
				
				if (key.equals("say_") || key.equals("say_duration_elapsed_from_")) {
					if (!(list[1] instanceof Object[])) {  // capture user generated strings
						HashMap<String,Object> map = new HashMap<String,Object>(3);
						map.put("sprite_id", spriteId);
						map.put("string", list[1].toString());
						map.put("type", "say");
						stringsList.add(map);
					}
				}
				
				if (key.equals("think_") || key.equals("think_duration_elapsed_from_")) {
					if (!(list[1] instanceof Object[])) {  // capture user generated strings
						HashMap<String,Object> map = new HashMap<String,Object>(3);
						map.put("sprite_id", spriteId);
						map.put("string", list[1].toString());
						map.put("type", "think");
						stringsList.add(map);
					}
				}
				
				representation += list[0].toString();
			}
			
			for (int i=1;i<list.length;i++) {
				representation += evaluateBlock(list[i], spriteId, connected);
			}
			representation += ")";
		} else {
			representation += " " + ObjectName.quote(block.toString());
		}
		
		
		return representation;
	}
	
	//TODO move to db utils
	/**
	 * Finds and returns the project id of the project as specified by project name and user name.
	 */
	private String findProjectId(String projectname, String username) {
		try {
			PreparedStatement stmt = Loader.getConnectionForRemixProjectQuerying().prepareStatement(DatabaseConstants.REMIXED_FROM_PREPARED_STATEMENT);
			stmt.setString(1, projectname);
			stmt.setString(2, username);
			
			ResultSet rs = stmt.executeQuery();
			if (rs.next()) 
				return rs.getObject("id").toString();
			return "";
		} catch (SQLException e) {
			e.printStackTrace();
			return "";
		}
	}
	
}
